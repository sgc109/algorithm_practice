

# --------------
# Please enter the commit message for your changes. Everything below
# this paragraph is ignored, and an empty message aborts the commit.
# Just close the window to accept your message.
diff --git a/battleship.cpp b/battleship.cpp
new file mode 100644
index 0000000..e70663b
--- /dev/null
+++ b/battleship.cpp
@@ -0,0 +1,74 @@
+#include <stdio.h>
+#include <iostream>
+#include <vector>
+#include <algorithm>
+#include <string.h>
+#define REP(i,a,b) for(int i = a; i < b; ++i) 
+#define FOR(i,n) REP(i,0,n)
+
+using namespace std;
+
+struct Ship{
+	int x1,y1,x2,y2;
+	int weight;
+	int shipNum;
+};
+
+bool cmpX(Ship shipA, Ship shipB) {
+	return shipA.x1 < shipB.x1;
+}
+
+bool cmpY(Ship shipA, Ship shipB) {
+	return shipA.y1 < shipB.y1;
+}
+
+vector<Ship> v;
+vector<bool> defeated;
+int T,N,K,L;
+
+struct SegTree{
+	vector<Ship> maxArr;
+	int size;
+	SegTree(vector<Ship> &v) {
+		size = v.size();
+		maxArr.resize(4*size);
+		init(0, size-1, 1, v);
+	}
+	Ship init(int nodeLeft, int nodeRight, int node, vector<Ship> &v) {
+		if(nodeLeft == nodeRight) return maxArr[node] = v[nodeLeft];
+
+		int nodeMid = (nodeLeft + nodeRight) / 2;
+		Ship maxLeft = init(nodeLeft, nodeMid, 2*node, v);
+		Ship maxRight = init(nodeMid + 1, nodeRight, 2*node+1, v);
+
+		if(maxLeft.weight <= maxRight.weight) return maxArr[node] = maxRight;
+		return maxArr[node] = maxLeft;
+	}
+};
+
+int main() {
+	scanf("%d",&T);
+	FOR(t,T) {
+		scanf("%d%d%d",&N,&K,&L);
+		v = vector<Ship>(K);
+		defeated = vector<bool>(K);
+		
+		FOR(i,K) {
+			int x1,y1,x2,y2,w;
+			scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&w);
+			v[i].x1 = x1;
+			v[i].y1 = y1;
+			v[i].x2 = x2;
+			v[i].y2 = y2;
+			v[i].weight = w;
+			v[i].shipNum = i;
+		}
+		sort(v.begin(), v.end(), cmpX);
+		SegTree segTreeX(v);
+		sort(v.begin(), v.end(), cmpY);
+		SegTree segTreeY(v);
+	}
+
+
+	return 0;
+}
\ No newline at end of file
diff --git a/candy.cpp b/candy.cpp
new file mode 100644
index 0000000..c210ff2
--- /dev/null
+++ b/candy.cpp
@@ -0,0 +1,33 @@
+#include <stdio.h>
+#include <iostream>
+#include <vector>
+#define REP(i,a,b) for(int i = a; i < b; ++i) 
+#define FOR(i,n) REP(i,0,n)
+
+using namespace std;
+
+
+struct SegTree{
+	vector<int> rangeSum;
+	int size;
+	SegTree(vector<int> &v) {
+		size = v.size();
+		rangeSum.resize(4*size);
+	}
+
+};
+
+vector<int> candies;
+int n;
+
+int main() {
+	candies = vector<int>(1000000,0);
+	SegTree segTree(candies);
+	
+	scanf("%d",&n);
+	FOR(i,n) {
+		
+	}
+
+	return 0;
+}
\ No newline at end of file
diff --git a/fermat.cpp b/fermat.cpp
new file mode 100644
index 0000000..9fa36b5
--- /dev/null
+++ b/fermat.cpp
@@ -0,0 +1,31 @@
+#include <stdio.h>
+
+const int MOD = 1000000007;
+
+int fermat(int n) {
+	int power = MOD - 2;
+	long long ret = 1;
+	long long start = n;
+	while(power) {
+		if(power & 1) ret = (ret*start) % MOD;
+		start = (start * start) % MOD;
+		power >>= 1;
+	}
+	return ret % MOD;
+}
+
+int main(){
+	long long aLong = 1000000000;
+	long long bLong = 100000007;
+	long long cLong = 2;
+
+	int a = 1000000000;
+	int b = 100000007;
+	int c = 2;
+
+	printf("%d\n",(aLong*bLong/cLong)%MOD);
+	printf("%d\n",((((long long)a*b)%MOD)*fermat(c))%MOD);
+
+
+	return 0;
+}
\ No newline at end of file
diff --git a/input.txt b/input.txt
new file mode 100644
index 0000000..277a377
--- /dev/null
+++ b/input.txt
@@ -0,0 +1,8 @@
+5
+1 4 3 5 2
+5
+1 2 -3
+1 4 2
+2 5
+1 2 4
+2 5
\ No newline at end of file
diff --git a/military.cpp b/military.cpp
new file mode 100644
index 0000000..9c99c23
--- /dev/null
+++ b/military.cpp
@@ -0,0 +1,98 @@
+#include <stdio.h>
+#include <iostream>
+#include <vector>
+#define REP(i,a,b) for(int i = a; i < b; ++i)
+#define FOR(i,n) REP(i,0,n)
+
+using namespace std;
+
+int corp;
+
+struct SegTree {
+	vector<int> rangeSum;
+	int size;
+	SegTree(vector<int> &v) {
+		size = v.size();
+		rangeSum.resize(4*size);
+		init(0,size-1,1,v);
+	}
+	int init(int nodeLeft, int nodeRight, int node, vector<int> &v) {
+		if(nodeLeft == nodeRight) return rangeSum[node] = v[nodeLeft];
+
+		int nodeMid = (nodeLeft + nodeRight) / 2;
+		int sumLeft = init(nodeLeft, nodeMid, 2*node, v);
+		int sumRight = init(nodeMid+1, nodeRight, 2*node+1, v);
+
+		return rangeSum[node] = sumLeft + sumRight;
+	}
+	int find(int nodeLeft, int nodeRight, int node, int id) {
+		if(rangeSum[node] == id) {
+			corp = nodeRight;
+			return -1;
+		}
+		if(rangeSum[node] < id) return rangeSum[node];
+		if(nodeLeft == nodeRight) {
+			corp = nodeLeft;
+			return -1;
+		}
+
+		int nodeMid = (nodeLeft + nodeRight) / 2;
+		int sumLeft = find(nodeLeft, nodeMid, 2*node, id);
+		if(sumLeft == -1) return -1;
+		id -= sumLeft;
+		int sumRight = find(nodeMid+1, nodeRight, 2*node+1, id);
+
+		return -1;
+	}
+	int update(int nodeLeft, int nodeRight, int node, int pos, int add) {
+		if(nodeLeft == nodeRight && nodeRight == pos) {
+			rangeSum[node] += add;
+			return rangeSum[node];
+		}
+		if(nodeRight < pos || pos < nodeLeft) return rangeSum[node];
+
+		int nodeMid = (nodeLeft + nodeRight) / 2;
+		int sumLeft = update(nodeLeft, nodeMid, 2*node, pos, add);
+		int sumRight = update(nodeMid+1, nodeRight, 2*node+1, pos, add);
+
+		return rangeSum[node] = sumLeft + sumRight;
+	}
+	int find(int id) {
+		return find(0,size-1,1,id);
+	}
+	int update(int pos, int add) {
+		return update(0,size-1,1,pos,add);
+	}
+};
+
+int main() {
+	int n, m;
+	vector<int> v;
+	scanf("%d",&n);
+	v.resize(n);
+	FOR(i,n) {
+		scanf("%d",&v[i]);
+	}
+	SegTree segTree(v);
+	scanf("%d",&m);
+	FOR(i,m) {
+		/*FOR(j,4*segTree.size) {
+			printf("%d ",segTree.rangeSum[j]);
+		}
+		printf("\n");*/
+		int a,b,c;
+		scanf("%d",&a);
+		if(a==1) {
+			scanf("%d%d",&b,&c);
+			--b;
+			segTree.update(b,c);
+		}
+		else {
+			scanf("%d",&b);
+			segTree.find(b);
+			printf("%d\n",corp+1);
+		}
+	}
+
+	return 0;
+}	
\ No newline at end of file
diff --git a/segMulti.cpp b/segMulti.cpp
new file mode 100644
index 0000000..17bf5e4
--- /dev/null
+++ b/segMulti.cpp
@@ -0,0 +1,82 @@
+#include <stdio.h>
+#include <vector>
+#define REP(i,a,b) for(int i = a; i < b; ++i)
+#define FOR(i,n) REP(i,0,n)
+
+using namespace std;
+
+const int MOD = 1000000007;
+
+int N,M,K;
+vector<int> v;
+
+struct SegTree{
+	vector<int> rangeMult;
+	int size;
+	SegTree(vector<int> &v) {
+		size = v.size();
+		rangeMult.resize(4*size);
+		init(0,size-1,1,v);
+	}
+	int init(int nodeLeft, int nodeRight, int node, vector<int> &v) {
+		if(nodeLeft == nodeRight) return rangeMult[node] = v[nodeLeft];
+
+		int nodeMid = (nodeLeft + nodeRight) / 2;
+
+		int leftMult = init(nodeLeft, nodeMid, 2*node, v);
+		int rightMult = init(nodeMid+1, nodeRight, 2*node+1, v);
+
+		return rangeMult[node] = ((long long)leftMult * rightMult) % MOD;
+	}
+	int query(int nodeLeft, int nodeRight, int left, int right, int node) {
+		if(right < nodeLeft || nodeRight < left) return 1;
+		if(left <= nodeLeft && nodeRight <= right) return rangeMult[node];
+
+		int nodeMid = (nodeLeft + nodeRight) / 2;
+
+		int leftMult = query(nodeLeft, nodeMid, left, right, 2*node);
+		int rightMult = query(nodeMid+1, nodeRight, left, right, 2*node+1);
+
+
+		return ((long long)leftMult * rightMult) % MOD;
+	}
+	int update(int nodeLeft, int nodeRight, int node, int pos, int value) {
+		if(pos < nodeLeft || nodeRight < pos) return rangeMult[node];
+		if(nodeLeft == nodeRight && nodeLeft == pos) return rangeMult[node] = value;
+
+		int nodeMid = (nodeLeft + nodeRight) / 2;
+
+		int leftMult = update(nodeLeft, nodeMid, 2*node, pos, value);
+		int rightMult = update(nodeMid+1, nodeRight, 2*node+1, pos, value);
+
+
+		return rangeMult[node] = ((long long)leftMult * rightMult) % MOD;
+	}
+	int query(int left, int right) {
+		return query(0, size-1, left, right, 1);
+	}
+	int update(int pos, int value) {
+		return update(0, size-1, 1, pos, value);
+	}
+};
+
+int main() {
+	scanf("%d%d%d",&N,&M,&K);
+	v.resize(N);
+	FOR(i,N) {
+		scanf("%d",&v[i]);
+	}
+	SegTree segTree(v);
+	FOR(i,M+K) {
+		int a,b,c;
+		scanf("%d%d%d",&a,&b,&c);
+		if(a == 1) {
+			segTree.update(b-1,c);
+		}
+		else {
+			printf("%d\n",segTree.query(b-1,c-1));
+		}
+	}
+
+	return 0;
+}
\ No newline at end of file
diff --git a/test.cpp b/test.cpp
new file mode 100644
index 0000000..31d446a
--- /dev/null
+++ b/test.cpp
@@ -0,0 +1,62 @@
+#define REP(i,a,b) for(int i = a;i < b; ++i)
+#define FOR(i,n) REP(i,0,n)
+#define LONG long long
+#define INFL 0x7fffffffffffffff
+  
+#include<iostream>
+#include<cstdio>
+#include<string>
+#include<vector>
+#include<algorithm>
+#include<string>
+#include<cstring>
+#include<cmath>
+  
+using namespace std;
+ 
+struct RangeTree {
+  int n;
+  vector<int> rangeMax;
+  RangeTree(vector<int> &v) {
+      n = v.size();
+      rangeMax.resize(4*n);
+      init(0,n-1,1,v);
+  }
+  int init(int left, int right, int node, vector<int> &v) {
+      if(left==right) return rangeMax[node] = v[left];
+       
+      int mid = (left+right)/2;
+      return rangeMax[node] = max(init(left,mid,2*node,v),init(mid+1,right,2*node+1,v));
+  }
+  int RMQ(int nodeLeft, int nodeRight, int left, int right, int node) {
+      if(nodeLeft > right || nodeRight < left) return -1987564321;
+      if(left <= nodeLeft && nodeRight <= right) return rangeMax[node];
+      int mid = (nodeLeft+nodeRight)/2;
+      return max(RMQ(nodeLeft,mid,left,right,2*node),RMQ(mid+1,nodeRight,left,right,2*node+1));
+  }
+  int RMQ(int left, int right) {
+      return RMQ(0, n-1, left, right, 1);
+  }
+};
+ 
+int main() {
+    vector<int> ma;
+    vector<int> mi;
+    int n,m;
+    scanf("%d%d",&n,&m);
+    FOR(i,n) {
+        int tmp;
+        scanf("%d",&tmp);
+        ma.push_back(tmp);
+        mi.push_back(-tmp);
+    }
+    RangeTree maxTree(ma);
+    RangeTree minTree(mi);
+     
+    FOR(i,m) {
+        int a,b;
+        scanf("%d%d",&a,&b);
+        printf("%d %d\n",-minTree.RMQ(a-1,b-1),maxTree.RMQ(a-1,b-1));
+    }
+    return 0;
+}
\ No newline at end of file