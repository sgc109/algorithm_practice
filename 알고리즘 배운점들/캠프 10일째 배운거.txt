persistent segtree 는 트리에서 루트에서부터 다른 모든 노드까지의 경로상의 정보를 저장해야할때
모든 노드에 대해 저장하려면 시간,공간 복잡도가 n^2 이다. 그런데 잘보면
부모 노드까지의 정보에서 한노드만 추가되는것이기때문에  

LR max flow 는 sink 에서 source 로 가는 capacity 무한대의 가상의 간선을 이어줘서 LR circulation 을
만족하는지 보고(만족하지 않는다면 불가능한거) 만족한다면 LR circulation 에서 max Flow + 모든 하한 들의합
이 답이다.
그런데 LR circulation 에서 max Flow 는 어떻게 구하냐면 모든 간선들의 capacity를 R-L 로 바꿔주고
가상의 source 를 만들어서 간선들에 대해 보내는쪽의 노드에게는 가상의 source 에서 L 만큼 보내줘서
L이 흐르게 보장해주고 받는쪽의 노드 가상의 sink 가 L만큼 회수해가게 해준뒤 이 그래프에서
max flow 를 구해서 그게 모든 L의 합과 같으면 LR circulation 을 만족하는것임

보통 n^2 에 계산하는것을 nlgn 으로 바꿔야할땐 주로 분할정복으로 품(가장 가까운 두점, 수열 뒤집기?)
흔히 그냥 어려운문제들도 분할정복으로 많이풀수있음
그래서 트리에서 쿼리를 날릴때 centroid 를 중심으로 재귀적으로 분할정복으로 나누면됨
경로의 합이 K인 거 찾을때 centroid 로함
(centroid 는 트리에서 n^2으로 계산해야하는것을 nlgn 으로 할수있도록해줌)
분할정복은 배열에서 효과적인만큼 트리에서도 유용함. 트리에서는 전반적으로 다 어렵기때문

트리에서 path query 를 할땐 보통 dfs ordering 으로 트리를 펴거나 HLD 를 사용한다.
centroid 로는 좀 불편함

HLD 나 persistent segtree 는 다 path 에 대한 알고리즘임